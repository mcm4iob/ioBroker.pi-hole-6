# Automatically merge Dependabot PRs V2
# This workflow handles automatic merging of Dependabot PRs based on configuration

name: Auto-Merge Dependabot PRs V2

on:
  # Trigger when a PR is opened or updated
  # WARNING: This needs to be run in the PR base, DO NOT build untrusted code in this action
  pull_request_target:
    types: [opened, synchronize, reopened]
  
  # Allow manual workflow dispatch
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number (e.g., 345) or PR URL to process'
        required: true
        type: string

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    # Only run if actor is dependabot or if manually triggered
    if: github.event_name == 'workflow_dispatch' || github.actor == 'dependabot[bot]'
    
    permissions:
      contents: write
      pull-requests: write
      
    steps:
      - name: Extract PR number
        id: extract-pr
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual trigger - extract PR number from input
            PR_INPUT="${{ github.event.inputs.pr_number }}"
            # Check if input is a URL or just a number
            if [[ "$PR_INPUT" =~ ^https?:// ]]; then
              # Extract number from URL (e.g., https://github.com/owner/repo/pull/345)
              # Using sed for better portability
              PR_NUMBER=$(echo "$PR_INPUT" | sed -n 's|.*/pull/\([0-9]*\).*|\1|p')
            else
              # Already a number
              PR_NUMBER="$PR_INPUT"
            fi
          else
            # Automatic trigger - use PR number from event
            PR_NUMBER="${{ github.event.pull_request.number }}"
          fi
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "Processing PR #$PR_NUMBER"
      
      - name: Get PR details
        id: pr-details
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.extract-pr.outputs.pr_number }};
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            core.setOutput('author', pr.user.login);
            core.setOutput('title', pr.title);
            core.setOutput('base', pr.base.ref);
            core.setOutput('head', pr.head.ref);
            core.setOutput('head_sha', pr.head.sha);
            
            return pr;
      
      - name: Check if PR is from Dependabot
        id: check-dependabot
        run: |
          AUTHOR="${{ steps.pr-details.outputs.author }}"
          if [ "$AUTHOR" != "dependabot[bot]" ]; then
            echo "PR #${{ steps.extract-pr.outputs.pr_number }} was not created by Dependabot (author: $AUTHOR)"
            echo "is_dependabot=false" >> $GITHUB_OUTPUT
          else
            echo "PR #${{ steps.extract-pr.outputs.pr_number }} was created by Dependabot"
            echo "is_dependabot=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Fetch Dependabot metadata
        if: steps.check-dependabot.outputs.is_dependabot == 'true'
        id: dependabot-metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata for decision making
        if: steps.check-dependabot.outputs.is_dependabot == 'true'
        id: metadata
        run: |
          # Extract update type from dependabot metadata
          # Format: "version-update:semver-patch", "version-update:semver-minor", "version-update:semver-major"
          UPDATE_TYPE_RAW="${{ steps.dependabot-metadata.outputs.update-type }}"
          
          if [[ "$UPDATE_TYPE_RAW" == *"semver-patch"* ]]; then
            UPDATE_TYPE="patch"
          elif [[ "$UPDATE_TYPE_RAW" == *"semver-minor"* ]]; then
            UPDATE_TYPE="minor"
          elif [[ "$UPDATE_TYPE_RAW" == *"semver-major"* ]]; then
            UPDATE_TYPE="major"
          else
            UPDATE_TYPE="unknown"
          fi
          
          echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
          echo "Update type: $UPDATE_TYPE"
          
          # Extract dependency type
          # Format: "direct:production" or "direct:development"
          DEPENDENCY_TYPE_RAW="${{ steps.dependabot-metadata.outputs.dependency-type }}"
          
          if [[ "$DEPENDENCY_TYPE_RAW" == *"production"* ]]; then
            DEPENDENCY_TYPE="production"
          elif [[ "$DEPENDENCY_TYPE_RAW" == *"development"* ]]; then
            DEPENDENCY_TYPE="development"
          else
            DEPENDENCY_TYPE="unknown"
          fi
          
          echo "dependency_type=$DEPENDENCY_TYPE" >> $GITHUB_OUTPUT
          echo "Dependency type: $DEPENDENCY_TYPE"
          
          # Log package information
          echo "Package name(s): ${{ steps.dependabot-metadata.outputs.dependency-names }}"
          echo "Previous version: ${{ steps.dependabot-metadata.outputs.previous-version }}"
          echo "New version: ${{ steps.dependabot-metadata.outputs.new-version }}"
      
      - name: Checkout repository
        if: steps.check-dependabot.outputs.is_dependabot == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr-details.outputs.base }}
      
      - name: Read and parse auto-merge configuration
        if: steps.check-dependabot.outputs.is_dependabot == 'true'
        id: read-config
        run: |
          CONFIG_FILE=".github/auto-merge.yml"
          
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "Configuration file $CONFIG_FILE not found"
            echo "Using default rules:"
            echo "- Patch updates: always merge"
            echo "- Minor updates: only for devDependencies"
            echo "- Major updates: never merge"
            echo "config_exists=false" >> $GITHUB_OUTPUT
            echo "config_json=[]" >> $GITHUB_OUTPUT
          else
            echo "Configuration file found"
            echo "config_exists=true" >> $GITHUB_OUTPUT
            cat "$CONFIG_FILE"
            
            # Convert YAML to JSON for easier parsing (compact, single line)
            # Note: python3 and PyYAML are available by default on ubuntu-latest runners
            CONFIG_JSON=$(python3 -c "import yaml, json; print(json.dumps(yaml.safe_load(open('$CONFIG_FILE'))))")
            echo "config_json=$CONFIG_JSON" >> $GITHUB_OUTPUT
          fi
      
      - name: Decide if should auto-merge
        if: steps.check-dependabot.outputs.is_dependabot == 'true'
        id: should-merge
        env:
          CONFIG_JSON: ${{ steps.read-config.outputs.config_json }}
        uses: actions/github-script@v7
        with:
          script: |
            const updateType = '${{ steps.metadata.outputs.update_type }}';
            const dependencyType = '${{ steps.metadata.outputs.dependency_type }}';
            const configExists = '${{ steps.read-config.outputs.config_exists }}' === 'true';
            
            console.log(`Update type: ${updateType}`);
            console.log(`Dependency type: ${dependencyType}`);
            console.log(`Config exists: ${configExists}`);
            
            let shouldMerge = false;
            
            if (configExists) {
              // Read and parse configuration from JSON passed via environment variable
              try {
                const configJson = process.env.CONFIG_JSON;
                const config = JSON.parse(configJson);
                
                console.log('Configuration:', JSON.stringify(config, null, 2));
                
                // Check each match rule
                for (const rule of config) {
                  const match = rule.match;
                  if (!match) continue;
                  
                  // Check dependency type
                  let depTypeMatches = true;
                  if (match.dependency_type === 'production' && dependencyType !== 'production') {
                    depTypeMatches = false;
                  }
                  if (match.dependency_type === 'development' && dependencyType !== 'development') {
                    depTypeMatches = false;
                  }
                  
                  // Check update type (only semver: types are supported)
                  let updateTypeMatches = false;
                  if (match.update_type) {
                    const matchType = match.update_type;
                    if (matchType.startsWith('semver:')) {
                      const semverType = matchType.replace('semver:', '');
                      updateTypeMatches = (updateType === semverType);
                    }
                    // Note: security: prefix is no longer supported
                  }
                  
                  if (depTypeMatches && updateTypeMatches) {
                    shouldMerge = true;
                    console.log('Match found:', match);
                    break;
                  }
                }
              } catch (err) {
                console.error('Error reading config:', err);
              }
            } else {
              // Default rules (no config file)
              if (updateType === 'patch') {
                // Always merge patch updates
                shouldMerge = true;
                console.log('Default rule: Patch update - will merge');
              } else if (updateType === 'minor') {
                // Merge minor updates for devDependencies only
                if (dependencyType === 'development') {
                  shouldMerge = true;
                  console.log('Default rule: Minor update for devDependency - will merge');
                } else {
                  console.log('Default rule: Minor update for production dependency - will NOT merge');
                }
              } else if (updateType === 'major') {
                // Never merge major updates
                console.log('Default rule: Major update - will NOT merge');
              }
            }
            
            core.setOutput('should_merge', shouldMerge.toString());
            console.log(`Decision: ${shouldMerge ? 'MERGE' : 'DO NOT MERGE'}`);
            
            return shouldMerge;
      
      - name: Log merge decision
        if: steps.check-dependabot.outputs.is_dependabot == 'true'
        run: |
          if [ "${{ steps.should-merge.outputs.should_merge }}" == "true" ]; then
            echo "✅ Decision: PR #${{ steps.extract-pr.outputs.pr_number }} WILL be auto-merged"
          else
            echo "❌ Decision: PR #${{ steps.extract-pr.outputs.pr_number }} will NOT be auto-merged"
          fi
      
      - name: Wait for other workflows
        if: steps.check-dependabot.outputs.is_dependabot == 'true' && steps.should-merge.outputs.should_merge == 'true'
        id: wait-for-checks
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.extract-pr.outputs.pr_number }};
            const headSha = '${{ steps.pr-details.outputs.head_sha }}';
            
            console.log(`Waiting for workflows on PR #${prNumber} (SHA: ${headSha})`);
            
            // Wait for checks to complete
            const maxWaitTime = 60 * 60 * 1000; // 1 hour
            const pollInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitTime) {
              // Get check runs for the commit
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: headSha,
                per_page: 100
              });
              
              // Filter out this workflow
              const otherChecks = checkRuns.check_runs.filter(check => 
                check.name !== 'auto-merge' && 
                check.name !== context.job
              );
              
              console.log(`Found ${otherChecks.length} other checks`);
              
              if (otherChecks.length === 0) {
                console.log('No other checks found, proceeding with merge');
                core.setOutput('checks_passed', 'true');
                return true;
              }
              
              // Check status of all checks
              const pending = otherChecks.filter(check => 
                check.status !== 'completed'
              );
              
              const failed = otherChecks.filter(check => 
                check.status === 'completed' && check.conclusion !== 'success' && check.conclusion !== 'skipped'
              );
              
              console.log(`Pending: ${pending.length}, Failed: ${failed.length}`);
              
              if (failed.length > 0) {
                console.error('Some checks failed:');
                failed.forEach(check => {
                  console.error(`  - ${check.name}: ${check.conclusion}`);
                });
                core.setOutput('checks_passed', 'false');
                core.setFailed('Some required checks failed');
                return false;
              }
              
              if (pending.length === 0) {
                console.log('All checks completed successfully');
                core.setOutput('checks_passed', 'true');
                return true;
              }
              
              // Wait before checking again
              console.log(`Waiting for ${pending.length} checks to complete...`);
              pending.forEach(check => {
                console.log(`  - ${check.name}: ${check.status}`);
              });
              
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
            
            // Timeout
            core.setFailed('Timeout waiting for checks to complete');
            core.setOutput('checks_passed', 'false');
            return false;
      
      - name: Merge PR
        if: |
          steps.check-dependabot.outputs.is_dependabot == 'true' && 
          steps.should-merge.outputs.should_merge == 'true' &&
          steps.wait-for-checks.outputs.checks_passed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = ${{ steps.extract-pr.outputs.pr_number }};
            
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
              });
              
              console.log(`✅ Successfully merged PR #${prNumber}`);
            } catch (error) {
              console.error(`Failed to merge PR #${prNumber}:`, error.message);
              core.setFailed(error.message);
            }
